<!doctype html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Scuttlebutt Protocol Guide</title>
    <link rel="icon" href="img/favicon.png"/>
    <link rel="stylesheet" href="css/fonts.css"/>
    <link rel="stylesheet" href="css/guide.css"/>
</head>
<body>
    <div class="block header">
        <header>
            <div class="title">
                <a href="index.html">
                    <div>
                        <img src="img/logo.svg"/>
                        <span>Scuttlebutt Protocol Guide</span>
                    </div>
                </a>
            </div>
            <nav>
                <a href="https://github.com/vtduncan/scuttlebutt-protocol-guide"><div>Repo</div></a>
                <a href="diary.html"><div>Dev Diary</div></a>
                <a href="mailto:scuttlebuttprotocolguide@vltf.org"><div>Feedback</div></a>
            </nav>
        </header>
    </div>
    <div class="block">
        <div class="main">
            <h1>Scuttlebutt Protocol Guide</h1>
            <p class="subtitle">How Scuttlebutt peers find and talk to each other</p>
        </div>
    </div>
    <div class="block section">
        <div class="main">
            <h2 id="handshake">Handshake</h2>
            <p>Once a Scuttlebutt client has discovered the IP address and port number of a peer they connect via TCP to exchange messages. The connection begins with a 4-step handshake to authenticate each peer and set up an encrypted channel.</p>
            <img src="img/message_flow.svg"/>
            <p>The handshake uses the <a href="https://dominictarr.github.io/secret-handshake-paper/shs.pdf">Secret Handshake key exchange</a> which is designed to have these security properties:</p>
            <ul>
                <li>After a successful handshake the peers have verified each other’s public keys.</li>
                <li>The handshake produces a shared secret that can be used with a bulk encryption cypher for exchanging further messages.</li>
                <li>The client must know the server’s public key before connecting. The server learns the client’s public key during the handshake.</li>
                <li>Once the client has proven their identity the server can decide they don’t want to talk to this client and disconnect without confirming their own identity.</li>
                <li>A man-in-the-middle cannot learn the public key of either peer.</li>
                <li>Both peers need to know a key that represents the particular Scuttlebutt network they wish to connect to, however a man-in-the-middle can’t learn this key from the handshake. If the handshake succeeds then both ends have confirmed that they wish to use the same network.</li>
                <li>Past handshakes cannot be replayed. Attempting to replay a handshake will not allow an attacker to discover or confirm guesses about the participants’ public keys.</li>
            </ul>
            <aside>
                <p><strong>Client</strong> is the computer initiating the TCP connection and <strong>server</strong> is the computer receiving it. Once the handshake is complete this distinction goes away.</p>
            </aside>
            <h3 id="starting-keys">Starting keys</h3>
            <p>Upon starting the handshake, the client and server know these keys:</p>
            <img src="img/starting_keys.svg"/>
            <h3 id="client-hello">1. Client hello</h3>
            <img src="img/client_hello.svg"/>
            <p>First the client sends their <img class="inline-key" src="img/key_little_a_public.svg"/> generated ephemeral key. Also included is an hmac that indicates the client wishes to use their key with this specific instance of the Scuttlebutt network.</p>
            <p>The <img class="inline-key" src="img/key_big_n.svg"/> network identifier is a fixed 32-byte key. Changing the key allows separate networks to be created, for example private networks or testnets. An eavesdropper cannot extract the network identifier directly from what is sent over the wire, although they could confirm a guess that it is the main Scuttlebutt network because that identifier is publicly known.</p>
            <p>The server stores the client’s ephemeral public key and uses the hmac to verify that the client is using the same network identifier.</p>
            <h3 id="server-hello">2. Server hello</h3>
            <img src="img/server_hello.svg"/>
            <p>The server responds with their own <img class="inline-key" src="img/key_little_b_public.svg"/> ephemeral public key and hmac. The client stores the key and verifies that they are also using the same network identifier.</p>
            <h3 id="shared-secret-derivation-1">Shared secret derivation</h3>
            <img src="img/shared_secret_derivation_1.svg"/>
            <div>
                <p>Now that ephemeral keys have been sent, both ends use them to derive a shared secret <img class="inline-key" src="img/key_little_a_little_b.svg"/> using scalar multiplication.</p>
                <p>The client and server each combine their own ephemeral secret key with the other’s ephemeral public key to produce the same shared secret on both ends. An eavesdropper doesn’t know either secret key so they can’t generate the shared secret. A man-in-the-middle could swap out the ephemeral keys in messages 1 and 2 for their own keys, so the shared secret <img class="inline-key" src="img/key_little_a_little_b.svg"/> alone is not enough for the client and server to know that they are talking to each other and not a man-in-the-middle.</p>
                <p>Because the client already knows the <img class="inline-key" src="img/key_big_b_public.svg"/> server’s long term public key, both ends derive a second secret <img class="inline-key" src="img/key_little_a_big_b.svg"/> that will allow the client to send a message that only the real server can read and not a man-in-the-middle.</p>
            </div>
            <aside>
                <p><strong>Scalar multiplication</strong> is a function for deriving shared secrets from a secret key and a public key.</p>
                <p>The order of arguments matters. In the NaCl API the secret key is provided first. Note that the existing Ed25519 keys must first be converted to Curve25519 keys.</p>
            </aside>
            <h3 id="client-accept">3. Client accept</h3>
            <img src="img/client_accept.svg"/>
            <div>
                <p>The client reveals their identity to the server by sending their <img class="inline-key" src="img/key_big_a_public.svg"/> long term public key. The client proves their identity and binds it to this handshake by using their <img class="inline-key" src="img/key_big_a_secret.svg"/> long term secret key to sign the keys that were used earlier in the handshake.</p>
                <p>The client’s message is enclosed in a secret box to ensure that only the server can read it. Upon receiving it, the server opens the box, stores the client’s long term public key and verifies the signature.</p>
                <p>An all-zero nonce is used for the secret box. The secret box construction requires that all secret boxes using a particular key must use different nonces. Using a zero nonce is allowed here because this is the only secret box that ever uses the key <span class="key-formula"><em>sha256</em>(<em>concat</em>( <img class="inline-key" src="img/key_big_n.svg"/>, <img class="inline-key" src="img/key_little_a_little_b.svg"/>, <img class="inline-key" src="img/key_little_a_big_b.svg"/>))</span>.</p>
            </div>
            <aside>
                <p><strong>Detached signatures</strong> do not contain a copy of the message that was signed, only a tag that allows verifying the signature if you already know the message.</p>
                <p>Here it is okay because the server knows all the information needed to reconstruct the message that the client signed.</p>
            </aside>
            <h3 id="shared-secret-derivation-2">Shared secret derivation</h3>
            <img src="img/shared_secret_derivation_2.svg"/>
            <p>Now that the server knows the <img class="inline-key" src="img/key_big_a_public.svg"/> client’s long term public key, another shared secret <img class="inline-key" src="img/key_big_a_little_b.svg"/> is derived by both ends. The server uses this shared secret to send a message that only the real client can read and not a man-in-the-middle.</p>
            <h3 id="server-accept">4. Server accept</h3>
            <img src="img/server_accept.svg"/>
            <p>The server accepts the handshake by signing a message using their <img class="inline-key" src="img/key_big_b_secret.svg"/> long term secret key. It includes a copy of the client’s previous signature. The server’s signature is enclosed in a secret box using all of the shared secrets.</p>
            <p>Upon receiving it, the client opens the box and verifies the server’s signature.</p>
            <p>Similarly to the previous message, this secret box also uses an all-zero nonce because it is the only secret box that ever uses the key <span class="key-formula"><em>sha256</em>(<em>concat</em>( <img class="inline-key" src="img/key_big_n.svg"/>, <img class="inline-key" src="img/key_little_a_little_b.svg"/>, <img class="inline-key" src="img/key_little_a_big_b.svg"/>, <img class="inline-key" src="img/key_big_a_little_b.svg"/>))</span>. <em>(Note to self: check what box-stream uses.)</em></p>
            <h3 id="handshake-complete">Handshake complete</h3>
            <img src="img/final_shared_secret.svg"/>
            <p>At this point the handshake has succeeded. The client and server have proven their identities to each other.</p>
            <p>The shared secrets are combined and used in a bulk encryption cipher to provide a secure two-way channel for exchanging further messages.</p>
        </div>
    </div>
</body>
</html>
