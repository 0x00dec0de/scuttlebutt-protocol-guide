<!doctype html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Scuttlebutt Protocol Guide</title>
    <link rel="icon" href="img/favicon.png"/>
    <link rel="stylesheet" href="css/fonts.css"/>
    <link rel="stylesheet" href="css/guide.css"/>
</head>
<body>
    <header>
        <div class="title">
            <a href="index.html">
                <img src="img/logo.svg"/>
                <span>Scuttlebutt Protocol Guide</span>
            </a>
        </div>
        <nav>
            <a href="https://github.com/vtduncan/scuttlebutt-protocol-guide"><div>Repo</div></a>
            <a href="diary.html"><div>Dev Diary</div></a>
            <a href="mailto:scuttlebuttprotocolguide@vltf.org"><div>Feedback</div></a>
        </nav>
    </header>
    <main>
        <h1>Scuttlebutt Protocol Guide</h1>
        <p class="subtitle">How Scuttlebutt peers find and talk to each other</p>
        <hr/>
        <aside class="kicker section-kicker">
            <h2>Contents</h2>
        </aside>
        <div class="toc">
            <div class="col">
                <a class="s1 tbw">Introduction</a>
                <div class="section">
                    <a class="s1 tbw">Discovery</a>
                    <div class="s2">
                        <div><a class="tbw">Local network</a></div>
                        <div><a class="tbw">Pub message</a></div>
                        <div><a class="tbw">Invite code</a></div>
                    </div>
                </div>
            </div>
            <div class="col">
                <div class="section">
                    <a class="s1" href="#peer-connections">Peer connections</a>
                    <div class="s2">
                        <div><a href="#handshake">Handshake</a></div>
                        <div><a href="#box-stream">Box stream</a></div>
                        <div><a href="#rpc-protocol">RPC protocol</a></div>
                    </div>
                </div>
            </div>
            <div class="col">
                <div class="section">
                    <a class="s1 tbw">Feeds</a>
                    <div class="s2">
                        <div><a class="tbw">Structure</a></div>
                        <div><a class="tbw">createHistoryStream</a></div>
                        <div><a class="tbw">Message format</a></div>
                        <div><a class="tbw">Replication strategy</a></div>
                        <div><a class="tbw">Pubs and invites</a></div>
                    </div>
                </div>
            </div>
            <div class="col">
                <div class="section">
                    <a class="s1 tbw">Blobs</a>
                    <div class="s2">
                        <div><a class="tbw">Fetching</a></div>
                        <div><a class="tbw">Want and have</a></div>
                    </div>
                </div>
                <a class="s1 tbw">Implementations</a>
            </div>
        </div>
        <hr/>
    
        <h2 id="peer-connections">Peer connections</h2>

        <h3 id="handshake" class="first">Handshake</h3>
        <p>Once a Scuttlebutt client has discovered the IP address and port number of a peer they connect via TCP to exchange messages. The connection begins with a 4-step handshake to authenticate each peer and set up an encrypted channel.</p>
        <img src="img/message_flow.svg"/>
        <p>The handshake uses the <a href="https://dominictarr.github.io/secret-handshake-paper/shs.pdf">Secret Handshake key exchange</a> which is designed to have these security properties:</p>
        <ul>
            <li>After a successful handshake the peers have verified each other’s public keys.</li>
            <li>The handshake produces a shared secret that can be used with a bulk encryption cypher for exchanging further messages.</li>
            <li>The client must know the server’s public key before connecting. The server learns the client’s public key during the handshake.</li>
            <li>Once the client has proven their identity the server can decide they don’t want to talk to this client and disconnect without confirming their own identity.</li>
            <li>A man-in-the-middle cannot learn the public key of either peer.</li>
            <li>Both peers need to know a key that represents the particular Scuttlebutt network they wish to connect to, however a man-in-the-middle can’t learn this key from the handshake. If the handshake succeeds then both ends have confirmed that they wish to use the same network.</li>
            <li>Past handshakes cannot be replayed. Attempting to replay a handshake will not allow an attacker to discover or confirm guesses about the participants’ public keys.</li>
        </ul>
        <aside>
            <p><strong>Client</strong> is the computer initiating the TCP connection and <strong>server</strong> is the computer receiving it. Once the handshake is complete this distinction goes away.</p>
        </aside>

        <h4 id="starting-keys">Starting keys</h4>
        <p>Upon starting the handshake, the client and server know these keys:</p>
        <img src="img/starting_keys.svg"/>

        <h4 id="client-hello">1. Client hello</h4>
        <img src="img/client_hello.svg"/>

        <figure class="left-right code">
            <h5 class="left">Client sends <span class="msgsize">(64 bytes)</span></h5>
            <h5 class="right">Server verifies</h5>
            <pre class="left"><code>concat(
    nacl_auth(
        msg: client_ephemeral_pk,
        key: network_identifier
    ),
    client_ephemeral_pk
)</code></pre>
            <pre class="right"><code>assert(length(msg1) == 64)

client_hmac = first_32_bytes(msg1)
client_ephemeral_pk = last_32_bytes(msg1)

assert_nacl_auth_verify(
    authenticator: client_hmac,
    msg: client_ephemeral_pk,
    key: network_identifier
)</code></pre>
        </figure>

        <p>First the client sends their <img class="inline-key" src="img/key_little_a_public.svg"/> generated ephemeral key. Also included is an hmac that indicates the client wishes to use their key with this specific instance of the Scuttlebutt network.</p>
        <p>The <img class="inline-key" src="img/key_big_n.svg"/> network identifier is a fixed 32-byte key. On the main Scuttlebutt network it is:</p>
        <pre><code>d4a1cb88a66f02f8db635ce26441cc5dac1b08420ceaac230839b755845a9ffb</code></pre>
        <p>Changing the key allows separate networks to be created, for example private networks or testnets. An eavesdropper cannot extract the network identifier directly from what is sent over the wire, although they could confirm a guess that it is the main Scuttlebutt network because that identifier is publicly known.</p>
        <p>The server stores the client’s ephemeral public key and uses the hmac to verify that the client is using the same network identifier.</p>

        <h4 id="server-hello">2. Server hello</h4>
        <img src="img/server_hello.svg"/>

        <figure class="left-right code">
            <h5 class="left">Client verifies</h5>
            <h5 class="right">Server sends <span class="msgsize">(64 bytes)</span></h5>
            <pre class="left"><code>assert(length(msg2) == 64)

server_hmac = first_32_bytes(msg2)
server_ephemeral_pk = last_32_bytes(msg2)

assert_nacl_auth_verify(
    authenticator: server_hmac,
    msg: server_ephemeral_pk,
    key: network_identifier
)</code></pre>
            <pre class="right"><code>concat(
    nacl_auth(
        msg: server_ephemeral_pk,
        key: network_identifier
    ),
    server_ephemeral_pk
)</code></pre>
        </figure>

        <p>The server responds with their own <img class="inline-key" src="img/key_little_b_public.svg"/> ephemeral public key and hmac. The client stores the key and verifies that they are also using the same network identifier.</p>

        <h4 id="shared-secret-derivation-1">Shared secret derivation</h4>
        <img src="img/shared_secret_derivation_1.svg"/>

        <figure class="left-right code">
            <h5 class="left">Client computes</h5>
            <h5 class="right">Server computes</h5>
            <pre class="left"><code>shared_secret_ab = nacl_scalarmult(
    client_ephemeral_sk,
    server_ephemeral_pk
)

shared_secret_aB = nacl_scalarmult(
    client_ephemeral_sk,
    pk_to_curve25519(server_longterm_pk)
)</code></pre>
            <pre class="right"><code>shared_secret_ab = nacl_scalarmult(
    server_ephemeral_sk,
    client_ephemeral_pk
)

shared_secret_aB = nacl_scalarmult(
    sk_to_curve25519(server_longterm_sk),
    client_ephemeral_pk
)</code></pre>
        </figure>

        <div>
            <p>Now that ephemeral keys have been exchanged, both ends use them to derive a shared secret <img class="inline-key" src="img/key_little_a_little_b.svg"/> using scalar multiplication.</p>
            <p>The client and server each combine their own ephemeral secret key with the other’s ephemeral public key to produce the same shared secret on both ends. An eavesdropper doesn’t know either secret key so they can’t generate the shared secret. A man-in-the-middle could swap out the ephemeral keys in Messages 1 and 2 for their own keys, so the shared secret <img class="inline-key" src="img/key_little_a_little_b.svg"/> alone is not enough for the client and server to know that they are talking to each other and not a man-in-the-middle.</p>
            <p>Because the client already knows the <img class="inline-key" src="img/key_big_b_public.svg"/> server’s long term public key, both ends derive a second secret <img class="inline-key" src="img/key_little_a_big_b.svg"/> that will allow the client to send a message that only the real server can read and not a man-in-the-middle.</p>
        </div>
        <aside>
            <p><strong>Scalar multiplication</strong> is a function for deriving shared secrets from a pair of secret and public Curve25519 keys.</p>
            <p>The order of arguments matters. In the NaCl API the secret key is provided first.</p>
            <p>Note that long term keys are Ed25519 and must first be converted to Curve25519.</p>
        </aside>

        <h4 id="client-accept">3. Client accept</h4>
        <img src="img/client_accept.svg"/>

        <figure class="left-right code">
            <h5 class="left">Client computes</h5>
            <h5 class="right">Server verifies</h5>
            <pre class="left"><code>detached_signature_A = nacl_sign_detached(
    msg: concat(
        network_identifier,
        server_longterm_pk,
        sha256(shared_secret_ab)
    ),
    key: client_longterm_sk
)</code></pre>
            <pre class="right" style="grid-row: span 3;"><code>msg3_plaintext = assert_nacl_secretbox_open(
    ciphertext: msg3,
    nonce: 24_bytes_of_zeros,
    key: sha256(
        concat(
            network_identifier,
            shared_secret_ab,
            shared_secret_aB
        )
    )
)

assert(length(msg3_plaintext) == 96)

detached_signature_A = first_64_bytes(msg3_plaintext)
client_longterm_pk = last_32_bytes(msg3_plaintext)

assert_nacl_sign_verify_detached(
    sig: detached_signature_A,
    msg: concat(
        network_identifier,
        server_longterm_pk,
        sha256(shared_secret_ab)
    ),
    key: client_longterm_pk
)</code></pre>
            <h5 class="left">Client sends <span class="msgsize">(112 bytes)</span></h5>
            <pre class="left"><code>nacl_secret_box(
    msg: concat(
        detached_signature_A,
        client_longterm_pk
    ),
    nonce: 24_bytes_of_zeros,
    key: sha256(
        concat(
            network_identifier,
            shared_secret_ab,
            shared_secret_aB
        )
    )
)</code></pre>
        </figure>

        <div>
            <p>The client reveals their identity to the server by sending their <img class="inline-key" src="img/key_big_a_public.svg"/> long term public key. The client also makes a signature using their <img class="inline-key" src="img/key_big_a_secret.svg"/> long term secret key. By signing the keys used earlier in the handshake the client proves their identity and confirms that they do indeed wish to be part of this handshake.</p>
            <p>The client’s message is enclosed in a secret box to ensure that only the server can read it. Upon receiving it, the server opens the box, stores the client’s long term public key and verifies the signature.</p>
            <p>An all-zero nonce is used for the secret box. The secret box construction requires that all secret boxes using a particular key must use different nonces. Using a zero nonce is allowed here because this is the only secret box that ever uses the key <span class="key-formula"><em>sha256</em>(<em>concat</em>( <img class="inline-key" src="img/key_big_n.svg"/>, <img class="inline-key" src="img/key_little_a_little_b.svg"/>, <img class="inline-key" src="img/key_little_a_big_b.svg"/>))</span>.</p>
        </div>
        <aside>
            <p><strong>Detached signatures</strong> do not contain a copy of the message that was signed, only a tag that allows verifying the signature if you already know the message.</p>
            <p>Here it is okay because the server knows all the information needed to reconstruct the message that the client signed.</p>
        </aside>

        <h4 id="shared-secret-derivation-2">Shared secret derivation</h4>
        <img src="img/shared_secret_derivation_2.svg"/>

        <figure class="left-right code">
            <h5 class="left">Client computes</h5>
            <h5 class="right">Server computes</h5>
            <pre class="left"><code>shared_secret_Ab = nacl_scalarmult(
    sk_to_curve25519(client_longterm_sk),
    server_ephemeral_pk
)</code></pre>
            <pre class="right"><code>shared_secret_Ab = nacl_scalarmult(
    server_ephemeral_sk,
    pk_to_curve25519(client_longterm_pk)
)</code></pre>
        </figure>

        <p>Now that the server knows the <img class="inline-key" src="img/key_big_a_public.svg"/> client’s long term public key, another shared secret <img class="inline-key" src="img/key_big_a_little_b.svg"/> is derived by both ends. The server uses this shared secret to send a message that only the real client can read and not a man-in-the-middle.</p>

        <h4 id="server-accept">4. Server accept</h4>
        <img src="img/server_accept.svg"/>

        <figure class="left-right code">
            <h5 class="left">Client verifies</h5>
            <h5 class="right">Server computes</h5>
            <pre class="left" style="grid-row: span 3;"><code>detached_signature_B = assert_nacl_secretbox_open(
    ciphertext: msg4,
    nonce: 24_bytes_of_zeros,
    key: sha256(
        concat(
            network_identifier,
            shared_secret_ab,
            shared_secret_aB,
            shared_secret_Ab
        )
    )
)

assert_nacl_sign_verify_detached(
    sig: detached_signature_B,
    msg: concat(
        network_identifier,
        detached_signature_A,
        client_longterm_pk,
        sha256(shared_secret_ab)
    ),
    key: server_longterm_pk
)</code></pre>
            <pre class="right"><code>detached_signature_B = nacl_sign_detatched(
    msg: concat(
        network_identifier,
        detached_signature_A,
        client_longterm_pk,
        sha256(shared_secret_ab)
    ),
    key: server_longterm_sk
)</code></pre>
            <h5 class="right">Server sends <span class="msgsize">(80 bytes)</span></h5>
            <pre class="right"><code>nacl_secret_box(
    msg: detached_signature_B,
    nonce: 24_bytes_of_zeros,
    key: sha256(
        concat(
            network_identifier,
            shared_secret_ab,
            shared_secret_aB,
            shared_secret_Ab
        )
    )
)</code></pre>
        </figure>
        <p>The server accepts the handshake by signing a message using their <img class="inline-key" src="img/key_big_b_secret.svg"/> long term secret key. It includes a copy of the client’s previous signature. The server’s signature is enclosed in a secret box using all of the shared secrets.</p>
        <p>Upon receiving it, the client opens the box and verifies the server’s signature.</p>
        <p>Similarly to the previous message, this secret box also uses an all-zero nonce because it is the only secret box that ever uses the key <span class="key-formula"><em>sha256</em>(<em>concat</em>( <img class="inline-key" src="img/key_big_n.svg"/>, <img class="inline-key" src="img/key_little_a_little_b.svg"/>, <img class="inline-key" src="img/key_little_a_big_b.svg"/>, <img class="inline-key" src="img/key_big_a_little_b.svg"/>))</span>.</p>

        <h4 id="handshake-complete">Handshake complete</h4>
        <img src="img/final_shared_secret.svg"/>
        <p>At this point the handshake has succeeded. The client and server have proven their identities to each other.</p>
        <p>The shared secrets established during the handshake are used to set up a pair of box streams for securely exchanging further messages.</p>

        <h3 id="box-stream">Box stream</h3>
        <p>Box stream is the bulk encryption protocol used to exchange messages following the handshake until the connection ends. It is designed to protect messages from being read or modified by a man-in-the-middle.</p>
        <p>Each message in a box stream has a header and body. The header is always 34 bytes long and says how long the body will be.</p>
        <img src="img/box_stream_overview.svg"/>

        <h4 id="sending">Sending</h4>
        <p>Sending a message involves encrypting the body of the message and preparing a header for it. Two secret boxes are used; one to protect the header and another to protect the body.</p>
        <img src="img/box_stream_send.svg" class="pagewidth"/>

        <h4 id="receiving">Receiving</h4>
        <p>Receiving a message involves reading the header to find out how long the body is then reassembling and opening the body secret box.</p>
        <img src="img/box_stream_receive.svg" class="pagewidth"/>

        <h4 id="goodbye">Goodbye</h4>
        <p>The stream ends with a special “goodbye” header. Because the goodbye header is authenticated it allows a receiver to tell the difference between the connection genuinely being finished and a man-in-the-middle forcibly resetting the underlying TCP connection.</p>
        <img src="img/box_stream_goodbye.svg" class="pagewidth"/>
        <p>When a receiver opens a header and finds that it contains all zeros then they will know that the connection is finished.</p>

        <h4 id="keys-and-nonces">Keys and nonces</h4>
        <p>Two box streams are used at the same time when Scuttlebutt peers communicate. One is for client-to-server messages and the other is for server-to-client messages. The two streams use different keys and starting nonces for their secret boxes.</p>
        <img src="img/box_stream_params.svg" class="pagewidth"/>
        <p>The starting nonce is used for the first header in the stream (“secret box 1” in the above figures), then incremented for the first body (“secret box 2”), then incremented for the next header and so on.</p>

        <h3 id="rpc-protocol">RPC protocol</h3>
        <div>
            <p>Scuttlebutt peers make requests to each other using an RPC protocol. Typical requests include asking for the latest messages in a particular feed or requesting a blob.</p>
            <p>The RPC protocol can interleave multiple requests so that a slow request doesn’t block following ones. It also handles long-running asynchronous requests for notifying when an event occurs and streams that deliver multiple responses over time.</p>
            <p>Similar to the box stream protocol, the RPC protocol consists of fixed-length headers followed by variable-length bodies. There is also a goodbye message which is just a zeroed out header.</p>
            <img src="img/rpc_overview.svg"/>
        </div>
        <aside>
            <p><strong>Remote procedure calls</strong> are where a computer exposes a set of procedures that another computer can call over the network.</p>
            <p>The requester tells the responder the name of the procedure they wish to call along with any arguments. The responder performs the action and returns a value back to the requester.</p>
        </aside>
        <p>Both peers make requests to each other at the same time using the pair of box streams that have been established. The box streams protect the RPC protocol from eavesdropping and tampering.</p>
        <img src="img/rpc_alignment.svg"/>
        <aside style="position: relative; top: 36px;">
            <p>RPC messages are not necessarily aligned to box stream boxes.</p>
            <p>Multiple RPC messages may be put inside one box or a single RPC message may be split over several boxes.</p>
        </aside>

        <h4 id="header-structure">Header structure</h4>
        <p>RPC headers contain a set of flags to say what type of message it is, a field specifying its length and a request number which allows matching requests with their responses when there are several active at the same time.</p>
        <img src="img/rpc_header.svg"/>

        <h4 id="request-format">Request format</h4>
        <p>To make an RPC request, send a JSON message containing the name of the procedure you wish to call, the type of procedure and any arguments.</p>
        <p>The name is a list of strings. For a top-level procedure like <em>createHistoryStream</em> the list only has one element: <code>["createHistoryStream"]</code>. Procedures relating to blobs are grouped in the blobs namespace, for example to use <em>blobs.get</em> send the list: <code>["blobs", "get"]</code>.</p>
        <div>
            <p>There are two types of procedure used when Scuttlebutt peers talk to each other:</p>
            <ul>
                <li><em>Source</em> procedures return multiple responses over time and are used for streaming data or continually notifying when new events occur. When making one of these requests, the stream flag in the RPC header must be set.</li>
                <li><em>Async</em> procedures return a single response. Async responses can arrive quickly or arrive much later in response to a one-off event.</li>
            </ul>
            <p>For each procedure in the RPC protocol you must already know whether it is source or async and correctly specify this in the request body.</p>
        </div>
        <aside>
            <p>The original Scuttlebot implementation also has other internal procedures and procedure types which are used by graphical user interfaces like Patchwork.</p>
            <p>This guide only covers the procedures that are publicly available to other Scuttlebutt peers.</p>
        </aside>

        <h4 id="source-example">Source example</h4>
        <p>This RPC message shows an example of a <em>createHistoryStream</em> request:</p>

        <aside class="kicker" style="align-self: start; position: relative; top: 58px;">
            <p>JSON messages don’t have indentation or whitespace when sent over the wire.</p>
        </aside>
        <figure class="request-response">
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "name": ["createHistoryStream"],
    "type": "source",
    "args": [
        {
            "id": "@FCX/tsDLpubCPKKfIrw4gc+SQkHcaD17s7GI6i/ziWY=.ed25519"
        }
    ]
}</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
        </figure>

        <div>
            <p><em>createHistoryStream</em> is how Scuttlebutt peers ask each other for a list of messages posted by a particular feed. It has one argument that is a JSON dictionary specifying more options about the request. <em>id</em> is the only required option and says which feed you are interested in.</p>
            <p>Because this is the first RPC request, the request number is 1. The next request made by this peer will be numbered 2. The other peer will also use request number 1 for their first request, but the peers can tell these apart because they know whether they sent or received each request.</p>
        </div>
        <aside>
            <p>To convert a long term Scuttlebutt public key into a feed ID, base64 encode the public key (with the base64 variant that uses <code>+</code> and <code>/</code>, the final padding <code>=</code> is also required). Then put an <code>@</code> sign on the front and <code>.ed25519</code> on the end.</p>
        </aside>
        <p>Now the responder begins streaming back responses:</p>

        <figure class="request-response">
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "key": "%XphMUkWQtomKjXQvFGfsGYpt69sgEY7Y4Vou9cEuJho=.sha256",
    "value": {
        "previous": null,
        "author": "@FCX/tsDLpubCPKKfIrw4gc+SQkHcaD17s7GI6i/ziWY=.ed25519",
        "sequence": 1,
        "timestamp": 1514517067954,
        "hash": "sha256",
        "content": {
            "type": "post",
            "text": "This is the first post!"
        },
        "signature": "QYOR/zU9dxE1aKBaxc3C0DJ4gRyZtlMfPLt+CGJcY73sv5abKK
                      Kxr1SqhOvnm8TY784VHE8kZHCD8RdzFl1tBA==.sig.ed25519"
    },
    "timestamp": 1514517067956
}</code></pre>
            </div>
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "key": "%R7lJEkz27lNijPhYNDzYoPjM0Fp+bFWzwX0SmNJB/ZE=.sha256",
    "value": {
        "previous": "%XphMUkWQtomKjXQvFGfsGYpt69sgEY7Y4Vou9cEuJho=.sha256",
        "author": "@FCX/tsDLpubCPKKfIrw4gc+SQkHcaD17s7GI6i/ziWY=.ed25519",
        "sequence": 2,
        "timestamp": 1514517078157,
        "hash": "sha256",
        "content": {
            "type": "post",
            "text": "Second post!"
        },
        "signature": "z7W1ERg9UYZjNfE72ZwEuJF79khG+eOHWFp6iF+KLuSrw8Lqa6
                      IousK4cCn9T5qFa8E14GVek4cAMmMbjqDnAg==.sig.ed25519"
    },
    "timestamp": 1514517078160
}</code></pre>
            </div>
        </figure>
        <aside style="align-self: start; position: relative; top: 29px;">
            <p>Because the responses are part of a stream, their RPC headers have the stream flag set.</p>
            <p>All responses use the same request number as the original request but negative.</p>
        </aside>

        <p>Each message posted by the feed is sent back in its own response. This feed only contains two messages. To signal the end of the stream, the responder sends an RPC message with both the stream and end/err flags set and a JSON body of <code>true</code>.</p>

        <figure class="request-response">
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">Yes</span>
                </div>
                <pre><code>true</code></pre>
            </div>
        </figure>

        <h4 id="async-example">Async example</h4>
        <p>The only public async procedure is <em>blobs.has</em>, which peers use to ask each other whether they have a particular blob.</p>
        <p>In this example the requester is asking the responder if they have blob <code>&amp;WWw4tQJ6…</code>:</p>

        <figure class="request-response">
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">2</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">No</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "name": ["blobs", "has"],
    "type": "async",
    "args": ["&amp;WWw4tQJ6ZrM7o3gA8lOEAcO4zmyqXqb/3bmIKTLQepo=.sha256"]
}</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
        </figure>

        <p>The responder does in fact have this blob so they respond with <code>true</code>. Because this is an async procedure and not a stream, there is only one response and no need to close the stream afterwards:</p>

        <figure class="request-response">
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-2</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">No</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>true</code></pre>
            </div>
        </figure>

        <h4 id="error-example">Error example</h4>

        <p>Let’s take the previous example and introduce a programming mistake to see how the RPC protocol handles errors:</p>

        <figure class="request-response">
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">3</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">No</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "name": ["blobs", "has"],
    "type": "async",
    "args": ["<strong>this was a mistake</strong>"]
}</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-3</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">No</span>
                    <span class="key">End/err</span><span class="value">Yes</span>
                </div>
                <pre><code>{
    "name": "Error",
    "message": "invalid hash:this was a mistake",
    "stack": "…"
}</code></pre>
            </div>
        </figure>

        <p>Most importantly, the response has the end/err flag set to indicate that an error occurred. The original Scuttlebot implementation also includes an error message and a JavaScript stack trace.</p>
        <p>For source type procedures an error will also end the stream because the end/err flag has the dual purpose of ending streams and indicating that an error occurred.</p>

        <h3 id="list-of-rpc-procedures">List of RPC procedures</h3>

        <h4 id="createHistoryStream">createHistoryStream</h4>
        <p>As shown above, <em>createHistoryStream</em> asks a peer for a list of messages posted in a particular feed.</p>

        <figure class="request-response">
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "name": ["createHistoryStream"],
    "type": "source",
    "args": [
        {
            "id": "@FCX/tsDLpubCPKKfIrw4gc+SQkHcaD17s7GI6i/ziWY=.ed25519",
            "sequence": 2,
            "limit": 1,
            "live": false,
            "old": true,
            "sync": false,
            "keys": true
        }
    ]
}</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
        </figure>

        <p><em>createHistoryStream</em> takes one argument which is a dictionary of additional options that controls how the feed is returned. Valid options are:</p>
        <table class="defs">
            <tr>
                <td>id</td>
                <td>ID of the feed to return messages from. Required.</td>
            </tr>
            <tr>
                <td>sequence</td>
                <td>Only return messages later than this sequence number. If not specified then start from the very beginning of the feed.</td>
            </tr>
            <tr>
                <td>limit</td>
                <td>Maximum number of messages to return. If the limit is exceeded only the earliest messages are returned. Default: unlimited.</td>
            </tr>
            <tr>
                <td>live</td>
                <td>If true, keep the stream alive and send new messages as they are posted. If false, end the stream after messages are sent and don’t wait for new ones. Default: false.</td>
            </tr>
            <tr>
                <td>old</td>
                <td>Used together with <em>live</em>. If false, don’t send existing messages posted by this feed, only send new messages as they arrive. If true, start by sending existing messages already posted by this feed. Default: true.</td>
            </tr>
            <tr>
                <td>keys</td>
                <td>If true, also include message IDs and timestamps of when each message was received by this peer. If false, just send the messages themselves. Default: true.</td>
            </tr>
        </table>

        <p>Here is a comparison of <em>createHistoryStream</em> responses with <em>keys</em> set to true and false:</p>

        <figure class="request-response">
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "name": ["createHistoryStream"],
    "type": "source",
    "args": [
        {
            "id": "@FCX/tsDLpubCPKKfIrw4gc+SQkHcaD17s7GI6i/ziWY=.ed25519",
            "keys": <strong>true</strong>
        }
    ]
}</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "<strong>key</strong>": "%XphMUkWQtomKjXQvFGfsGYpt69sgEY7Y4Vou9cEuJho=.sha256",
    "value": {
        "previous": null,
        "author": "@FCX/tsDLpubCPKKfIrw4gc+SQkHcaD17s7GI6i/ziWY=.ed25519",
        "sequence": 1,
        "timestamp": 1514517067954,
        "hash": "sha256",
        "content": {
            "type": "post",
            "text": "This is the first post!"
        },
        "signature": "QYOR/zU9dxE1aKBaxc3C0DJ4gRyZtlMfPLt+CGJcY73sv5abKK
                      Kxr1SqhOvnm8TY784VHE8kZHCD8RdzFl1tBA==.sig.ed25519"
    },
    "<strong>timestamp</strong>": 1514517067956
}</code></pre>
            </div>
            <hr class="mini"/>
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">2</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "name": ["createHistoryStream"],
    "type": "source",
    "args": [
        {
            "id": "@FCX/tsDLpubCPKKfIrw4gc+SQkHcaD17s7GI6i/ziWY=.ed25519",
            "keys": <strong>false</strong>
        }
    ]
}</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-2</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "previous": null,
    "author": "@FCX/tsDLpubCPKKfIrw4gc+SQkHcaD17s7GI6i/ziWY=.ed25519",
    "sequence": 1,
    "timestamp": 1514517067954,
    "hash": "sha256",
    "content": {
        "type": "post",
        "text": "This is the first post!"
    },
    "signature": "QYOR/zU9dxE1aKBaxc3C0DJ4gRyZtlMfPLt+CGJcY73sv5abKK
                  Kxr1SqhOvnm8TY784VHE8kZHCD8RdzFl1tBA==.sig.ed25519"
}</code></pre>
            </div>
        </figure>

        <h4 id="blobs.get">blobs.get</h4>
        <p><em>blobs.get</em> asks a peer to send you the contents of a blob. There is one argument which is the blob ID:</p>
        <figure class="request-response">
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "name": ["blobs", "get"],
    "type": "source",
    "args": ["&amp;uaGieSQDJcHfUp6hjIcIq55GoZh4Ug7tNmgaohoxrpw=.sha256"]
}</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
        </figure>
        
        <p>Blobs are referenced by the hash of their contents. The blob ID format is similar to that of feed IDs, but with <code>&amp;</code> on the front and <code>.sha256</code> on the end.</p>
        <p>Now the responder begins streaming back the contents of the blob. Each response has a body type of binary and contains a piece of the blob, starting from the beginning.</p>
        <p>This particular blob is 161,699 bytes long and the responder has decided to send it in pieces of 65,536 bytes each. That means two full pieces of 65,536 bytes will be sent and a final piece with the remaining 30,627 bytes.</p>

        <figure class="request-response">
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">Binary</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <div class="binary">

                    <code style="background:#e79f2755">ff</code><code style="background:#e79f2748">d8</code><code style="background:#e79f2755">ff</code><code style="background:#e79f274a">e0</code><code style="background:#e79f2700">00</code><code style="background:#e79f2705">10</code><code style="background:#e79f2718">4a</code><code style="background:#e79f2717">46</code><code style="background:#e79f2718">49</code><code style="background:#e79f2717">46</code><code style="background:#e79f2700">00</code><code style="background:#e79f2700">01</code><code style="background:#e79f2700">02</code><code style="background:#e79f2700">00</code><code style="background:#e79f2700">00</code><code style="background:#e79f2700">01</code><code style="background:#e79f2700">00</code><code style="background:#e79f2700">01</code><code style="background:#e79f2700">00</code><code style="background:#e79f2700">00</code><code style="background:#e79f2755">ff</code><code style="background:#e79f2749">db</code><code style="background:#e79f2700">00</code><code style="background:#e79f2716">43</code>
                    <code style="background:#e79f2700">00</code><code style="background:#e79f2702">08</code><code style="background:#e79f2702">06</code><code style="background:#e79f2702">06</code><code style="background:#e79f2702">07</code><code style="background:#e79f2702">06</code><code style="background:#e79f2701">05</code><code style="background:#e79f2702">08</code><code style="background:#e79f2702">07</code><code style="background:#e79f2702">07</code><code style="background:#e79f2702">07</code><code style="background:#e79f2703">09</code><code style="background:#e79f2703">09</code><code style="background:#e79f2702">08</code><code style="background:#e79f2703">0a</code><code style="background:#e79f2704">0c</code><code style="background:#e79f2706">14</code><code style="background:#e79f2704">0d</code><code style="background:#e79f2704">0c</code><code style="background:#e79f2703">0b</code><code style="background:#e79f2703">0b</code><code style="background:#e79f2704">0c</code><code style="background:#e79f2708">19</code><code style="background:#e79f2706">12</code>
                    <code style="background:#e79f2706">13</code><code style="background:#e79f2705">0f</code><code style="background:#e79f2706">14</code><code style="background:#e79f2709">1d</code><code style="background:#e79f2708">1a</code><code style="background:#e79f270a">1f</code><code style="background:#e79f270a">1e</code><code style="background:#e79f2709">1d</code><code style="background:#e79f2708">1a</code><code style="background:#e79f2709">1c</code><code style="background:#e79f2709">1c</code><code style="background:#e79f270a">20</code><code style="background:#e79f270c">24</code><code style="background:#e79f270f">2e</code><code style="background:#e79f270d">27</code><code style="background:#e79f270a">20</code><code style="background:#e79f270b">22</code><code style="background:#e79f270e">2c</code><code style="background:#e79f270b">23</code><code style="background:#e79f2709">1c</code><code style="background:#e79f2709">1c</code><code style="background:#e79f270d">28</code><code style="background:#e79f2712">37</code><code style="background:#e79f270d">29</code>
                    <code style="background:#e79f270e">2c</code><code style="background:#e79f2710">30</code><code style="background:#e79f2710">31</code><code style="background:#e79f2711">34</code><code style="background:#e79f2711">34</code><code style="background:#e79f2711">34</code><code style="background:#e79f270a">1f</code><code style="background:#e79f270d">27</code><code style="background:#e79f2713">39</code><code style="background:#e79f2714">3d</code><code style="background:#e79f2712">38</code><code style="background:#e79f2710">32</code><code style="background:#e79f2714">3c</code><code style="background:#e79f270f">2e</code><code style="background:#e79f2711">33</code><code style="background:#e79f2711">34</code><code style="background:#e79f2710">32</code><code style="background:#e79f2755">ff</code><code style="background:#e79f2749">db</code>
                    <div class="fadeout">…65536 bytes total</div>
                </div>
            </div>
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">Binary</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <div class="binary">
                    <code style="background:#e79f273e">ba</code><code style="background:#e79f274c">e4</code><code style="background:#e79f2730">92</code><code style="background:#e79f2710">31</code><code style="background:#e79f2744">ce</code><code style="background:#e79f2722">68</code><code style="background:#e79f2726">74</code><code style="background:#e79f2745">d0</code><code style="background:#e79f2746">d4</code><code style="background:#e79f2733">99</code><code style="background:#e79f2734">9e</code><code style="background:#e79f2722">66</code><code style="background:#e79f273d">b9</code><code style="background:#e79f2751">f3</code><code style="background:#e79f2707">17</code><code style="background:#e79f274f">ef</code><code style="background:#e79f270e">2b</code><code style="background:#e79f270a">20</code><code style="background:#e79f2749">dc</code><code style="background:#e79f2702">07</code><code style="background:#e79f2738">a8</code><code style="background:#e79f274f">ef</code><code style="background:#e79f272e">8a</code><code style="background:#e79f2746">d3</code>
                    <code style="background:#e79f273c">b5</code><code style="background:#e79f273d">b9</code><code style="background:#e79f2711">33</code><code style="background:#e79f2705">0f</code><code style="background:#e79f2711">34</code><code style="background:#e79f2730">90</code><code style="background:#e79f271d">57</code><code style="background:#e79f2737">a7</code><code style="background:#e79f270b">23</code><code style="background:#e79f2738">a9</code><code style="background:#e79f2752">f6</code><code style="background:#e79f2711">35</code><code style="background:#e79f2731">93</code><code style="background:#e79f270d">29</code><code style="background:#e79f273d">b8</code><code style="background:#e79f2730">92</code><code style="background:#e79f271b">52</code><code style="background:#e79f2746">d2</code><code style="background:#e79f2720">61</code><code style="background:#e79f2718">49</code><code style="background:#e79f2708">18</code><code style="background:#e79f271c">55</code><code style="background:#e79f2709">1d</code><code style="background:#e79f2714">3e</code>
                    <code style="background:#e79f273c">b4</code><code style="background:#e79f2730">91</code><code style="background:#e79f271e">5b</code><code style="background:#e79f273b">b2</code><code style="background:#e79f2735">a1</code><code style="background:#e79f270e">2c</code><code style="background:#e79f274b">e1</code><code style="background:#e79f2717">46</code><code style="background:#e79f2729">7b</code><code style="background:#e79f2727">77</code><code style="background:#e79f2711">35</code><code style="background:#e79f270a">1e</code><code style="background:#e79f2743">ca</code><code style="background:#e79f2741">c5</code><code style="background:#e79f2751">f3</code><code style="background:#e79f2749">dc</code><code style="background:#e79f274d">e8</code><code style="background:#e79f2707">16</code><code style="background:#e79f271e">5b</code><code style="background:#e79f2723">69</code><code style="background:#e79f2702">07</code><code style="background:#e79f2745">cf</code><code style="background:#e79f2710">31</code><code style="background:#e79f2704">0d</code>
                    <code style="background:#e79f274d">e8</code><code style="background:#e79f2748">d8</code><code style="background:#e79f2711">35</code><code style="background:#e79f2708">19</code><code style="background:#e79f273c">b5</code><code style="background:#e79f272f">8d</code><code style="background:#e79f2709">1c</code><code style="background:#e79f2742">c8</code><code style="background:#e79f270a">1f</code><code style="background:#e79f2726">73</code><code style="background:#e79f2705">11</code><code style="background:#e79f272b">83</code><code style="background:#e79f272e">8c</code><code style="background:#e79f2722">67</code><code style="background:#e79f2750">f2</code><code style="background:#e79f2739">ac</code><code style="background:#e79f270d">29</code><code style="background:#e79f2709">1d</code><code style="background:#e79f2742">c6</code>
                    <div class="fadeout">…65536 bytes total</div>
                </div>
            </div>
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">Binary</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <div class="binary">
                    <code style="background:#e79f2743">ca</code><code style="background:#e79f2751">f5</code><code style="background:#e79f2702">07</code><code style="background:#e79f2739">ad</code><code style="background:#e79f2712">37</code><code style="background:#e79f2721">63</code><code style="background:#e79f2721">64</code><code style="background:#e79f273a">af</code><code style="background:#e79f2743">ca</code><code style="background:#e79f2729">7d</code><code style="background:#e79f2751">f3</code><code style="background:#e79f2741">c5</code><code style="background:#e79f271d">58</code><code style="background:#e79f274c">e4</code><code style="background:#e79f272f">8e</code><code style="background:#e79f2702">07</code><code style="background:#e79f2743">cb</code><code style="background:#e79f274d">e9</code><code style="background:#e79f2747">d6</code><code style="background:#e79f272a">80</code><code style="background:#e79f2717">47</code><code style="background:#e79f2752">f7</code><code style="background:#e79f2728">78</code><code style="background:#e79f2752">f6</code>
                    <code style="background:#e79f2735">a0</code><code style="background:#e79f271d">57</code><code style="background:#e79f270b">22</code><code style="background:#e79f2703">0a</code><code style="background:#e79f2712">36</code><code style="background:#e79f274a">e0</code><code style="background:#e79f272e">8c</code><code style="background:#e79f2708">1a</code><code style="background:#e79f2728">79</code><code style="background:#e79f272d">88</code><code style="background:#e79f2706">14</code><code style="background:#e79f2712">38</code><code style="background:#e79f274f">ed</code><code style="background:#e79f274d">e9</code><code style="background:#e79f271a">4e</code><code style="background:#e79f2742">c8</code><code style="background:#e79f2714">3d</code><code style="background:#e79f2702">07</code><code style="background:#e79f2718">4a</code><code style="background:#e79f2725">70</code><code style="background:#e79f271b">51</code><code style="background:#e79f2734">9c</code><code style="background:#e79f272b">83</code><code style="background:#e79f2717">45</code>
                    <code style="background:#e79f272b">83</code><code style="background:#e79f2732">98</code><code style="background:#e79f272c">85</code><code style="background:#e79f2736">a2</code><code style="background:#e79f271f">5e</code><code style="background:#e79f2710">31</code><code style="background:#e79f2744">cd</code><code style="background:#e79f2713">39</code><code style="background:#e79f271b">53</code><code style="background:#e79f2723">6a</code><code style="background:#e79f273a">ae</code><code style="background:#e79f271d">57</code><code style="background:#e79f2714">3d</code><code style="background:#e79f2742">c7</code><code style="background:#e79f2737">a5</code><code style="background:#e79f2719">4b</code><code style="background:#e79f2734">9c</code><code style="background:#e79f270a">1e</code><code style="background:#e79f2711">33</code><code style="background:#e79f2733">9a</code><code style="background:#e79f2726">72</code><code style="background:#e79f2718">4a</code><code style="background:#e79f2742">c8</code><code style="background:#e79f273b">b2</code>
                    <code style="background:#e79f2701">05</code><code style="background:#e79f2709">1c</code><code style="background:#e79f2718">48</code><code style="background:#e79f2710">30</code><code style="background:#e79f2726">72</code><code style="background:#e79f2702">07</code><code style="background:#e79f2719">4c</code><code style="background:#e79f2754">fe</code><code style="background:#e79f2731">94</code><code style="background:#e79f271d">58</code><code style="background:#e79f2729">7c</code><code style="background:#e79f2741">c3</code><code style="background:#e79f2706">14</code><code style="background:#e79f272f">8e</code><code style="background:#e79f2739">ad</code><code style="background:#e79f2747">d7</code><code style="background:#e79f2714">3e</code><code style="background:#e79f2731">94</code><code style="background:#e79f2712">38</code>
                    <div class="fadeout">…30627 bytes total</div>
                </div>
            </div>
        </figure>

        <p>Finally, the stream ends with a JSON message of <code>true</code> with the end/err flag set:</p>

        <figure class="request-response">
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">Yes</span>
                </div>
                <pre><code>true</code></pre>
            </div>
        </figure>

        <p>Upon receiving the blob the requester should check that what they received matches the sha256 checksum they asked for.</p>

        <p><em>blobs.get</em> has an alternate form where the first argument is a JSON dictionary of options:</p>
        <figure class="request-response">
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">2</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "name": ["blobs", "get"],
    "type": "source",
    "args": [
        {
            "hash": "&amp;uaGieSQDJcHfUp6hjIcIq55GoZh4Ug7tNmgaohoxrpw=.sha256",
            "size": 161699,
            "max": 200000
        }
    ]
}</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
        </figure>

        <p>Valid options are:</p>
        <table class="defs">
            <tr>
                <td>hash</td>
                <td>ID of the blob. Required.</td>
            </tr>
            <tr>
                <td>size</td>
                <td>Expected size of the blob in bytes. If the blob is not exactly this size then reject the request. Optional.</td>
            </tr>
            <tr>
                <td>max</td>
                <td>Maximum size of the blob in bytes. If the blob is larger then reject the request. Only makes sense to specify <em>max</em> if you don’t already know <em>size</em>. Optional.</td>
            </tr>
        </table>
        <p>This form allows the receiver to reject the request if the blob is not the expected size or too large. When a request is rejected the responder sends back a single message with the end/err flag set containing a JSON error message.</p>

        <h4 id="blobs.getSlice">blobs.getSlice</h4>
        <p><em>blobs.getSlice</em> works like <em>blobs.get</em> but rather than receiving the entire blob, the requester specifies a start and end point and the responder only sends back bytes within that range:</p>
        <figure class="request-response">
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "name": ["blobs", "getSlice"],
    "type": "source",
    "args": [
        {
            "hash": "&amp;uaGieSQDJcHfUp6hjIcIq55GoZh4Ug7tNmgaohoxrpw=.sha256",
            "start": 65536,
            "end": 65584
        }
    ]
}</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">Binary</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <div class="binary">
                    <code style="background:#e79f273e">ba</code><code style="background:#e79f274c">e4</code><code style="background:#e79f2730">92</code><code style="background:#e79f2710">31</code><code style="background:#e79f2744">ce</code><code style="background:#e79f2722">68</code><code style="background:#e79f2726">74</code><code style="background:#e79f2745">d0</code><code style="background:#e79f2746">d4</code><code style="background:#e79f2733">99</code><code style="background:#e79f2734">9e</code><code style="background:#e79f2722">66</code><code style="background:#e79f273d">b9</code><code style="background:#e79f2751">f3</code><code style="background:#e79f2707">17</code><code style="background:#e79f274f">ef</code><code style="background:#e79f270e">2b</code><code style="background:#e79f270a">20</code><code style="background:#e79f2749">dc</code><code style="background:#e79f2702">07</code><code style="background:#e79f2738">a8</code><code style="background:#e79f274f">ef</code><code style="background:#e79f272e">8a</code><code style="background:#e79f2746">d3</code>
                    <code style="background:#e79f273c">b5</code><code style="background:#e79f273d">b9</code><code style="background:#e79f2711">33</code><code style="background:#e79f2705">0f</code><code style="background:#e79f2711">34</code><code style="background:#e79f2730">90</code><code style="background:#e79f271d">57</code><code style="background:#e79f2737">a7</code><code style="background:#e79f270b">23</code><code style="background:#e79f2738">a9</code><code style="background:#e79f2752">f6</code><code style="background:#e79f2711">35</code><code style="background:#e79f2731">93</code><code style="background:#e79f270d">29</code><code style="background:#e79f273d">b8</code><code style="background:#e79f2730">92</code><code style="background:#e79f271b">52</code><code style="background:#e79f2746">d2</code><code style="background:#e79f2720">61</code><code style="background:#e79f2718">49</code><code style="background:#e79f2708">18</code><code style="background:#e79f271c">55</code><code style="background:#e79f2709">1d</code><code style="background:#e79f2714">3e</code>
                </div>
            </div>
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">Yes</span>
                </div>
                <pre><code>true</code></pre>
            </div>
        </figure>

        <p><em>Start</em> and <em>end</em> are byte offsets from the start of the blob and form a half-open interval, meaning the end byte is not included.</p>
        <img src="img/blobs_get_slice.svg"/>
        <p>Specifying <em>start</em> = 0 means start from the beginning of the blob. Specifying <em>end</em> = <em>size of the blob</em> means keep going all the way to the end of the blob.</p>
        <p><em>blobs.getSlice</em> also accepts the <em>size</em> and <em>max</em> options, which work the same as in <em>blobs.get</em>. These two options refer to the size of the entire blob, not the range requested.</p>

        <h4 id="blobs.has">blobs.has</h4>
        <p><em>blobs.has</em> is how you ask a peer whether they have a particular blob:</p>
        <figure class="request-response">
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">No</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "name": ["blobs", "has"],
    "type": "async",
    "args": ["&amp;uaGieSQDJcHfUp6hjIcIq55GoZh4Ug7tNmgaohoxrpw=.sha256"]
}</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">No</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>true</code></pre>
            </div>
        </figure>

        <p>If they don’t have the blob they will instead reply <code>false</code>.
        <p><em>blobs.has</em> is the only public RPC procedure of type <em>async</em> so remember to set the type correctly in the request and not set the stream flags.</p>
        <p>Multiple blobs can be queried in one go by giving a list of blob IDs:</p>
        <figure class="request-response">
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">2</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">No</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "name": ["blobs", "has"],
    "type": "async",
    "args": [
        [
            "&amp;uaGieSQDJcHfUp6hjIcIq55GoZh4Ug7tNmgaohoxrpw=.sha256",
            "&amp;WWw4tQJ6ZrM7o3gA8lOEAcO4zmyqXqb/3bmIKTLQepo=.sha256",
            "&amp;G1qgWe3fuJgZR0CxAocN2SDUYUcveLWQzjpXG0GVH5U=.sha256"
        ]
    ]
}</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
        </figure>
        <p>The response is a list where each <code>true</code> or <code>false</code> corresponds to a blob that was queried:</p>
        <figure class="request-response">
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-2</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">No</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>[true, true, false]</code></pre>
            </div>
        </figure>

        <h4 id="blobs.changes">blobs.changes</h4>
        <p><em>blobs.changes</em> notifies the requester every time the responder acquires a new blob.</p>
        <figure class="request-response">
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "name": ["blobs", "changes"],
    "type": "source",
    "args": []
}</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
        </figure>
        <p>Later, when the responder acquires a new blob it sends the blob ID back. Responses use the RPC string message type, not JSON:</p>
        <figure class="request-response">
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">String</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>&amp;ldhEQXm0KOzFrkTlVSELj+yKULwyHdCskYc93dJdooM=.sha256</code></pre>
            </div>
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">String</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>&amp;ENoWuph/CdIvhEdiyOjrAS8nLAUpjneNqPXJNs7ORH4=.sha256</code></pre>
            </div>
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">String</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>&amp;qpC5X1GanJcw6K2UavJw9JNToPCLcUhbaTSY+vSnz+o=.sha256</code></pre>
            </div>
        </figure>

        <p>Once started the stream will stay open until the requester cancels it:</p>
        <figure class="request-response">
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">Yes</span>
                </div>
                <pre><code>true</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">Yes</span>
                </div>
                <pre><code>true</code></pre>
            </div>
        </figure>

        <h4 id="blobs.createWants">blobs.createWants</h4>
        <p><em>blobs.createWants</em> asks a peer to tell you which blobs they want, and also allows the peer to tell you which blobs they have (like <em>blobs.changes</em>).</p>

        <figure class="request-response">
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{
    "name": ["blobs", "createWants"],
    "type": "source",
    "args": []
}</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{}</code></pre>
            </div>
        </figure>

        <p>Responding with an empty dictionary <code>{}</code> means they don’t currently want any blobs. Later, when they want a particular blob the responder will send another response back:</p>

        <figure class="request-response">
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{"&amp;uaGieSQDJcHfUp6hjIcIq55GoZh4Ug7tNmgaohoxrpw=.sha256": -1}</code></pre>
            </div>
        </figure>
        <aside style="align-self: start; position: relative; top: 19px;">
            <p>Only one blob is allowed per response. Send multiple responses if you want more than one blob.</p>
        </aside>

        <p>The <code>-1</code> means the responder wants this blob themselves. <code>-2</code> means they know someone who wants the blob. <code>-3</code> means they know someone who knows someone who wants the blob, and so on.</p>
        <p>Implementations can pick a limit and ignore blob requests that come from further out than their threshold. The reference implementation forwards requests with <code>-1</code> or <code>-2</code> to peers it is currently connected to, but does not forward requests with <code>-3</code> or further out. When forwarding a request, remember to subtract one from the number so that the request does not keep propagating through the network in an infinite loop.</p>
        <p>The responder can also say that they now have a particular blob, and its size in bytes:</p>

        <figure class="request-response">
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">No</span>
                </div>
                <pre><code>{"&amp;uaGieSQDJcHfUp6hjIcIq55GoZh4Ug7tNmgaohoxrpw=.sha256": 161699}</code></pre>
            </div>
        </figure>
        <aside style="align-self: start; position: relative; top: 18px;">
            <p><em>Have</em> and <em>want</em> messages can be distinguished because <em>have</em> messages use a positive number whereas <em>want</em> messages use a negative number.</p>
        </aside>

        <p>If the requester wishes to cancel the stream, they can do so with:</p>
        <figure class="request-response">
            <div class="request">
                <div class="header">
                    <span class="key">Request number</span><span class="value">1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">Yes</span>
                </div>
                <pre><code>true</code></pre>
            </div>
            <img class="request-arrow" src="img/arrow.svg"/>
            <img class="response-arrow" src="img/arrow.svg"/>
            <div class="response">
                <div class="header">
                    <span class="key">Request number</span><span class="value">-1</span>
                    <span class="key">Body type</span><span class="value">JSON</span>
                    <span class="key">Stream</span><span class="value">Yes</span>
                    <span class="key">End/err</span><span class="value">Yes</span>
                </div>
                <pre><code>true</code></pre>
            </div>
        </figure>

        <p>When Scuttlebutt peers connect, they usually set up a pair of <em>blobs.createWants</em> streams to let each other know which blobs they want and have. When a peer sees that they have a blob that their partner (or someone they know) wants, they will send a <em>have</em> message via their <em>blobs.createWants</em> stream and their partner can retrieve it with <em>blobs.get</em> or <em>blobs.getSlice</em>.</p>
        <aside class="kicker" style="position: relative; top: 48px;">
            <p>By fetching blobs on behalf of one another, Scuttlebutt peers can reach blobs beyond who they are immediately connected to.</p>
        </aside>
        <img src="img/blobs_fetch.svg"/>

    </main>
</body>
</html>
